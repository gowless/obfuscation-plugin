package xyz.xenondevs.vetric

import xyz.xenondevs.bytebase.jvm.JavaArchive
import xyz.xenondevs.bytebase.jvm.VirtualClassPath
import xyz.xenondevs.vetric.config.VetricConfig
import xyz.xenondevs.vetric.jvm.Library
import xyz.xenondevs.vetric.logging.DiscardingLogger
import xyz.xenondevs.vetric.logging.Logger

class Vetric(val logger: Logger, val isDebug: Boolean) {
    
    constructor() : this(DiscardingLogger, false)
    
    constructor(isDebug: Boolean) : this(DiscardingLogger, isDebug)
    
    constructor(logger: Logger) : this(logger, false)
    
    @Volatile
    var exit = false
    
    val version
        get() = VERSION
    
    fun run(config: VetricConfig) {
        logger.info("Vetric v$version running on Java " + System.getProperty("java.version"))
        val jar = loadJars(config)
        applyTransformers(config, jar)
        saveOutput(config, jar)
    }
    
    private fun loadJars(config: VetricConfig): JavaArchive {
        logger.info("Loading input jar and libraries")
        val jar = JavaArchive(config.input)
        val libraries = config.libraries
        VirtualClassPath.loadJarWithDependencies(jar, libraries)
        return jar
    }
    
    private fun applyTransformers(config: VetricConfig, jar: JavaArchive) {
        logger.info("Loading transformer configs...")
        val transformers = config.registry.enabled
        transformers.forEach {
            it.vetric = this
            it.prepare(jar)
        }
        // Second loop to properly obfuscate any methods generated by Transformer#prepare
        transformers.forEach { transformer ->
            logger.info("Applying " + transformer.name + "...")
            transformer.transform(jar)
        }
    }
    
    private fun saveOutput(config: VetricConfig, jar: JavaArchive) {
        logger.info("Saving jar...")
        config.libraries.filter(Library::isExtracted).forEach { it.extractInto(jar) }
        jar.writeFile(config.output)
    }
    
    companion object Data {
        const val VERSION = "0.0.1"
    }
    
}